# 具体实现

## 目录
1. [项目结构](#项目结构)
2. [核心模块](#核心模块)
3. [数据流程](#数据流程)
4. [关键函数](#关键函数)
5. [代码示例](#代码示例)

---

## 项目结构

```
city_surface_energy_balance/
├── src/
│   ├── __init__.py              # 模块导出接口
│   ├── __main__.py              # 命令行入口
│   ├── physics.py               # 物理计算主工作流
│   │
│   ├── radiation/               # 辐射和能量平衡计算
│   │   ├── __init__.py
│   │   ├── constants.py         # 物理常量
│   │   ├── solar_radiation.py   # 太阳辐射计算
│   │   ├── calc_net_radiation.py # 净辐射计算器
│   │   ├── calc_soil_heat.py    # 土壤热通量计算器
│   │   ├── calc_sensible_heat.py # 感热通量计算器
│   │   ├── calc_latent_heat.py  # 潜热通量计算器
│   │   ├── balance_equation.py  # 能量平衡系数计算
│   │   ├── raster_io.py         # 栅格I/O
│   │   └── workflow.py          # 能量平衡工作流
│   │
│   ├── aerodynamics/            # 空气动力学参数
│   │   ├── __init__.py
│   │   ├── constants.py         # LCZ相关常量
│   │   ├── atmospheric.py       # 大气参数（密度、风速）
│   │   ├── vapor_pressure.py    # 水汽压计算
│   │   ├── resistance.py        # 阻抗计算
│   │   ├── dem_downscaling.py   # DEM降尺度
│   │   ├── dewpoint_downscaling.py # 露点温度降尺度
│   │   └── workflow.py          # 空气动力学工作流
│   │
│   ├── landscape/               # 景观参数
│   │   ├── __init__.py
│   │   ├── roughness.py         # 粗糙度计算
│   │   ├── frontal_area.py      # 正面面积计算
│   │   └── resistance.py        # 景观阻抗
│   │
│   ├── regression/              # 街区级回归
│   │   ├── __init__.py
│   │   ├── als_regression.py    # ALS回归模型
│   │   └── aggregator.py        # 栅格聚合到街区
│   │
│   ├── analysis/                # 空间分析模块
│   │   ├── __init__.py
│   │   ├── spatial_analysis.py  # 空间自相关分析（水平交换项ΔQ_A）
│   │   ├── overflow_analysis.py # 溢出效应分析
│   │   └── counterfactual_analysis.py  # 反事实分析
│   │
│   └── utils/                   # 工具模块
│       ├── __init__.py
│       ├── raster_manager.py    # 栅格数据管理
│       ├── cached_collection.py # 缓存集合
│       ├── mapping.py           # LCZ映射
│       ├── district_regression.py # 街区回归工具
│       └── logger.py            # 日志
│
├── doc/                         # 文档
│   ├── 算法思想.md
│   ├── 数学模型.md
│   ├── 具体实现.md
│   └── 使用指南.md
│
├── doc-old/                     # 旧文档
├── examples/                    # 示例脚本
└── test/                        # 测试脚本
```

---

## 核心模块

### 1. radiation 模块

**职责**：计算辐射通量和能量平衡系数

**核心类**：

#### `NetRadiationCalculator`
计算净辐射及其系数：
```python
calc = NetRadiationCalculator(
    shortwave_down=S_down,
    surface_temperature=Ts,
    elevation=elev,
    albedo=albedo,
    surface_emissivity=eps0,
    ta_reference=Ta_ref
)

# 获取系数
coeffs = calc.net_radiation_coefficient
# {
#     'coeff2': Ta²的系数,
#     'coeff1': Ta的系数,
#     'const': 常数项
# }
```

#### `SensibleHeatFluxCalculator`
计算感热通量系数：
```python
calc = SensibleHeatFluxCalculator(
    surface_temperature=Ts,
    aerodynamic_resistance=rah,
    air_density=rho
)

coeffs = calc.sensible_heat_coefficient
# {
#     'coeff': ∂QH/∂Ta,
#     'const': QH的常数部分
# }
```

#### `LatentHeatFluxCalculator`
计算潜热通量（不依赖Ta）：
```python
calc = LatentHeatFluxCalculator(
    saturation_vapor_pressure=es,
    actual_vapor_pressure=ea,
    aerodynamic_resistance=rah,
    surface_resistance=rs,
    air_density=rho
)

QE = calc.latent_heat_flux
```

#### `StorageHeatFluxCalculator`
计算储热通量：
```python
calc = StorageHeatFluxCalculator(
    net_radiation=Q_star,
    surface_temperature=Ts,
    albedo=albedo,
    ndvi=ndvi,
    lcz=lcz
)

# 自然表面：SEBAL公式计算的ΔQ_Sg
# 不透水面：β × Q* (β ≈ 0.35)
Delta_Q_storage = calc.storage_heat_flux

# 建筑区回归特征（用于ALS估计建筑额外贡献）
storage_feature = calc.storage_feature
```

#### `calculate_energy_balance_coefficients()`
主函数，计算能量平衡系数：
```python
coeffs = calculate_energy_balance_coefficients(
    shortwave_down=S_down,
    surface_temperature=Ts,
    elevation=elev,
    albedo=albedo,
    ndvi=ndvi,
    saturation_vapor_pressure=es,
    actual_vapor_pressure=ea,
    aerodynamic_resistance=rah,
    surface_resistance=rs,
    surface_emissivity=eps0,
    surface_pressure=P,
    era5_air_temperature=Ta_era5,
    lcz=lcz
)

# 返回:
# {
#     'f_Ta_coeff2': Ta²系数,
#     'f_Ta_coeff1': Ta系数,
#     'residual': 残差,
#     'storage_feature': 建筑储热特征,
#     ...
# }
```

### 2. aerodynamics 模块

**职责**：计算空气动力学参数

#### `calculate_air_density()`
计算空气密度（依赖Ta）：
```python
from aerodynamics import calculate_air_density

rho = calculate_air_density(
    air_temperature=Ta,
    surface_pressure=P
)
```

#### `calculate_saturation_vapor_pressure()`
计算饱和水汽压（从Ts）：
```python
from aerodynamics import calculate_saturation_vapor_pressure

es = calculate_saturation_vapor_pressure(Ts)
```

#### `calculate_actual_vapor_pressure_from_dewpoint()`
计算实际水汽压（从露点温度）：
```python
from aerodynamics import calculate_actual_vapor_pressure_from_dewpoint

ea = calculate_actual_vapor_pressure_from_dewpoint(Td)
```

#### `calculate_aerodynamic_resistance()`
计算大气湍流热交换阻抗：
```python
from aerodynamics import calculate_aerodynamic_resistance

rah = calculate_aerodynamic_resistance(
    wind_speed=U,
    roughness_length=z0,
    lcz=lcz,
    displacement_height=d,
    measurement_height=10.0
)
```

#### `calculate_surface_resistance()`
计算表面阻抗：
```python
from aerodynamics import calculate_surface_resistance

rs = calculate_surface_resistance(
    ndvi=ndvi,
    lcz=lcz
)
```

### 3. regression 模块

**职责**：街区级回归分析

#### `DistrictAggregator`
将栅格数据聚合到街区：
```python
from regression import DistrictAggregator

aggregator = DistrictAggregator()

aggregated = aggregator.aggregate_rasters_to_districts(
    rasters={
        'f_Ta_coeff': coeffs['f_Ta_coeff'],
        'residual': coeffs['residual']
    },
    districts_gdf=districts,
    transform=transform,
    stats=['mean']
)
```

#### `ALSRegression`
ALS回归求解：
```python
from regression import ALSRegression

model = ALSRegression()

results = model.fit(
    X_F=X_F,  # 人为热特征
    X_S=X_S,  # 储热特征
    f_Ta_coeffs=f_Ta_coeffs,
    y_residual=y_residual,
    era5_Ta_mean=era5_Ta_mean,
    max_iter=20,
    tol=1e-4
)
```

### 4. analysis 模块

**职责**：空间分析、溢出效应分析和反事实分析

空间分析模块提供三种互补的分析工具：
1. **空间自相关分析**：量化水平交换项 ΔQ_A（气温空间自相关）
2. **溢出效应分析**：量化自然景观对建成区的降温溢出
3. **反事实分析**：通过LCZ替换情景估算自然景观的降温贡献

#### `SpatialWeightMatrix`
空间权重矩阵（使用稀疏矩阵优化，支持缓存）：
```python
from analysis import SpatialWeightMatrix

# 构建空间权重矩阵
spatial_weights = SpatialWeightMatrix(
    districts_gdf=districts_gdf,
    distance_threshold=5000.0,    # 距离阈值（米）
    decay_function='gaussian',     # 衰减函数：binary/linear/inverse/gaussian
    row_standardize=True,          # 是否行标准化
    cache_dir='./cache/spatial'    # 缓存目录
)

# 计算空间滞后项 W*Ta
W_Ta = spatial_weights.spatial_lag(Ta)

# 获取邻居统计
summary = spatial_weights.summary()
# {
#     'n_districts': 街区数量,
#     'distance_threshold': 距离阈值,
#     'avg_neighbors': 平均邻居数,
#     'isolated_districts': 孤立街区数,
#     ...
# }
```

#### `analyze_spatial_autocorrelation()`
空间滞后模型分析（水平交换项 ΔQ_A）：
```python
from analysis import analyze_spatial_autocorrelation

result = analyze_spatial_autocorrelation(
    Ta=Ta_per_district,           # 各街区气温
    spatial_weights=spatial_weights,
    verbose=True
)

# 返回:
# {
#     'rho': 空间自相关系数 ρ,
#     'intercept': 截距 μ,
#     'r_squared': R²,
#     'moran_i': Moran's I 统计量,
#     'moran_p': Moran's I p 值,
#     'spatial_lag': 空间滞后项 W*Ta,
#     'residuals': 模型残差
# }
```

#### `OverflowAnalyzer`
溢出效应分析器：
```python
from analysis import OverflowAnalyzer

analyzer = OverflowAnalyzer(
    natural_lcz_values=[11, 12, 13, 14],  # 自然景观LCZ
    built_lcz_values=list(range(1, 11)),   # 建成区LCZ
    verbose=True
)

result = analyzer.analyze(
    gdf=results_gdf,              # 含Ta和LCZ的GeoDataFrame
    ta_column='Ta_optimized',
    lcz_column='LCZ',
    distance_threshold=5000.0,
    decay_function='gaussian',
    cache_dir='./cache/spatial'
)

# 结果包含：
# - natural_neighbor_ratio: 每个街区的自然邻居占比
# - spillover_coeff: 溢出系数
# - local_moran_i: 局部Moran's I
# - cluster_type: 聚集类型 ('Hot-Hot', 'Cold-Cold', 'High-Low', 'Low-High')
# - spillover_by_lcz: 按LCZ类型的溢出效应

# 将结果添加到GeoDataFrame
gdf_with_results = analyzer.add_results_to_gdf(gdf)
```

#### `CounterfactualAnalyzer`
反事实分析器（降温贡献估算）：
```python
from analysis import CounterfactualAnalyzer

analyzer = CounterfactualAnalyzer(
    natural_lcz_values=[11, 12, 13, 14, 17],  # 自然景观LCZ
    replacement_lcz=6,  # 替代用的建成区LCZ（开敞低层）
    verbose=True
)

result = analyzer.analyze(
    als_model=als_model,          # 已拟合的ALS模型
    districts_gdf=districts_gdf,
    X_F=X_F,
    X_S=X_S,
    f_Ta_coeffs=f_Ta_coeffs,
    y_residual=y_residual,
    era5_Ta_mean=era5_Ta_mean,
    lcz_column='LCZ',
    include_spatial_analysis=True,
    spatial_distance_threshold=500.0
)

# 结果包含：
# - Ta_original: 原始气温
# - Ta_counterfactual: 反事实气温
# - cooling_contribution: 降温贡献 = Ta_counterfactual - Ta_original
# - mean_cooling: 自然景观平均降温
# - max_cooling: 最大降温

print(result.summary())
```

#### 便捷函数
```python
from analysis import analyze_overflow, estimate_cooling_contribution

# 溢出效应分析便捷函数
overflow_result, gdf_with_results = analyze_overflow(
    gdf=results_gdf,
    ta_column='Ta_optimized',
    lcz_column='LCZ',
    distance_threshold=5000.0,
    decay_function='gaussian',
    verbose=True
)

# 简化版降温贡献计算
cooling_stats = estimate_cooling_contribution(
    Ta_original=Ta_original,
    Ta_counterfactual=Ta_counterfactual,
    natural_mask=natural_mask,
    verbose=True
)
```

### 5. utils 模块

**职责**：数据管理和工具函数

#### `RasterCollection`
内存中的栅格数据集合：
```python
from utils import RasterCollection

collection = RasterCollection(
    target_resolution=10.0,
    target_crs='EPSG:32650'
)

collection.add_raster('LST', 'landsat_lst.tif', band=1)
collection.add_raster('NDVI', 'landsat_ndvi.tif', band=1)
```

#### `CachedRasterCollection`
磁盘缓存的栅格数据集合：
```python
from utils import CachedRasterCollection

collection = CachedRasterCollection(
    cache_dir=Path('./cache'),
    target_resolution=10.0,
    target_crs='EPSG:32650'
)

# 自动缓存到磁盘，支持重启后加载
```

---

## 数据流程

### 阶段1：物理计算（栅格级）

```python
# 1. 加载数据
collection = load_and_align_data(
    era5_path='era5.tif',
    landsat_path='landsat.tif',
    dem_path='dem.tif',
    lcz_path='lcz.tif',
    target_crs='EPSG:32650',
    target_resolution=10.0,
    cache_dir='./cache'
)

# 2. 计算空气动力学参数
aero_collection = calculate_aerodynamic_parameters(
    collection,
    cache_dir='./cache/aerodynamic'
)

# 3. 计算能量平衡系数
balance_collection = calculate_energy_balance(
    input_collection=collection,
    aero_collection=aero_collection,
    datetime_obj=datetime(2023, 8, 15, 10, 30),
    std_meridian=120.0,
    cache_dir='./cache/balance'
)
```

### 阶段2：空间聚合

```python
from regression import DistrictAggregator
import geopandas as gpd

# 加载街区数据
districts = gpd.read_file('districts.gpkg')

# 创建聚合器
aggregator = DistrictAggregator()

# 聚合栅格到街区
aggregated = aggregator.aggregate_rasters_to_districts(
    rasters={
        'f_Ta_coeff2': balance_collection.get_raster('f_Ta_coeff2'),
        'f_Ta_coeff1': balance_collection.get_raster('f_Ta_coeff1'),
        'residual': balance_collection.get_raster('residual'),
        'era5_air_temperature': balance_collection.get_raster('era5_air_temperature')
    },
    districts_gdf=districts,
    transform=balance_collection.transform,
    stats=['mean']
)
```

### 阶段3：街区回归

```python
from regression import ALSRegression

# 创建回归模型
model = ALSRegression()

# ALS回归求解
results = model.fit(
    X_F=X_F,
    X_S=X_S,
    f_Ta_coeffs=f_Ta_coeffs,
    y_residual=y_residual,
    era5_Ta_mean=era5_Ta_mean,
    max_iter=20,
    tol=1e-4
)

# 结果包含：
# - Ta_per_district: 各街区估算气温
# - coefficients: 回归系数
# - convergence_history: 收敛历史
```

### 阶段4：空间分析

```python
from analysis import (
    SpatialWeightMatrix,
    analyze_spatial_autocorrelation,
    analyze_overflow,
    CounterfactualAnalyzer
)

# 1. 空间自相关分析（水平交换项 ΔQ_A）
spatial_weights = SpatialWeightMatrix(
    districts_gdf=districts,
    distance_threshold=5000.0,
    decay_function='gaussian',
    cache_dir='./cache/spatial'
)

autocorr_result = analyze_spatial_autocorrelation(
    Ta=results['Ta_per_district'],
    spatial_weights=spatial_weights,
    verbose=True
)
# 输出：Moran's I, 空间自相关系数 ρ, R² 等

# 2. 溢出效应分析
overflow_result, gdf_with_overflow = analyze_overflow(
    gdf=results_gdf,
    ta_column='Ta_optimized',
    lcz_column='LCZ',
    distance_threshold=5000.0,
    decay_function='gaussian',
    verbose=True
)
# 输出：自然邻居占比、溢出系数、局部Moran's I、聚集类型

# 3. 反事实分析（降温贡献估算）
cf_analyzer = CounterfactualAnalyzer(
    natural_lcz_values=[11, 12, 13, 14],
    replacement_lcz=6,
    verbose=True
)

cf_result = cf_analyzer.analyze(
    als_model=model,
    districts_gdf=districts,
    X_F=X_F,
    X_S=X_S,
    f_Ta_coeffs=f_Ta_coeffs,
    y_residual=y_residual,
    era5_Ta_mean=era5_Ta_mean,
    lcz_column='LCZ'
)

# 输出降温贡献摘要
print(cf_result.summary())
# 自然景观平均降温: X.XX K
# 最大降温: X.XX K
# 全域平均降温贡献: X.XX K
```

---

## 关键函数

### 能量平衡系数计算

**函数**：`calculate_energy_balance_coefficients()`

**位置**：`src/radiation/balance_equation.py`

**功能**：
1. 计算净辐射系数（Q*的Ta²、Ta、常数项）
2. 计算感热通量系数（QH的Ta系数）
3. 计算储热通量（根据LCZ分类）
4. 计算潜热通量（不依赖Ta）
5. 组合为能量平衡系数

**关键代码**：
```python
# 净辐射系数（二阶泰勒展开）
Q_star_coeffs = net_rad_calc.net_radiation_coefficient
# {
#     'coeff2': ε₀·6εₐσTa₀²,
#     'coeff1': -ε₀·8εₐσTa₀³,
#     'const': (1-α)S↓ + ε₀·3εₐσTa₀⁴ - ε₀σTs⁴
# }

# 感热通量系数
QH_coeffs = sensible_calc.sensible_heat_coefficient
# {
#     'coeff': -ρCp/rah,
#     'const': ρCp·Ts/rah
# }

# 组合
f_Ta_coeff2 = Q_star_coeffs['coeff2']
f_Ta_coeff1 = Q_star_coeffs['coeff1'] + QH_coeffs['coeff']
residual = Q_star_coeffs['const'] - Delta_Q_storage + QH_coeffs['const'] - QE
```

### ALS回归求解

**函数**：`fit_als_regression()`

**位置**：`src/regression/district_regression.py`

**功能**：
1. 固定Ta，估计线性系数（α, β）
2. 固定线性系数，优化每个街区的Ta
3. 迭代直到收敛

**关键代码**：
```python
# 步骤1：固定Ta，估计线性系数
y = -f_Ta_coeff2 * Ta**2 - f_Ta_coeff1 * Ta - residual
X = [X_F, X_S]  # 特征矩阵
coeffs = (X.T @ X)^(-1) @ X.T @ y

# 步骤2：固定系数，优化Ta
# 对每个街区k，求解二次方程：
# f_Ta_coeff2_k * Ta_k^2 + f_Ta_coeff1_k * Ta_k + residual_k + X_k @ coeffs = 0
Ta_k = solve_quadratic(f_Ta_coeff2_k, f_Ta_coeff1_k, residual_k + X_k @ coeffs)

# 步骤3：迭代
while not converged:
    update_coeffs()
    update_Ta()
```

---

## 代码示例

### 示例1：完整工作流

```python
from datetime import datetime
from pathlib import Path
from src.physics import load_and_align_data, calculate_aerodynamic_parameters
from src.radiation import calculate_energy_balance
from src.regression import DistrictAggregator, DistrictRegressionModel
import geopandas as gpd

# 1. 物理计算
collection = load_and_align_data(
    era5_path='data/era5.tif',
    landsat_path='data/landsat.tif',
    albedo_path='data/albedo.tif',
    dem_path='data/dem.tif',
    lcz_path='data/lcz.tif',
    target_crs='EPSG:32650',
    target_resolution=10.0,
    cache_dir='./cache'
)

aero_collection = calculate_aerodynamic_parameters(
    collection,
    cache_dir='./cache/aerodynamic'
)

balance_collection = calculate_energy_balance(
    input_collection=collection,
    aero_collection=aero_collection,
    datetime_obj=datetime(2023, 8, 15, 10, 30),
    std_meridian=120.0,
    cache_dir='./cache/balance'
)

# 2. 空间聚合
districts = gpd.read_file('data/districts.gpkg')
aggregator = DistrictAggregator()

aggregated = aggregator.aggregate_rasters_to_districts(
    rasters={
        'f_Ta_coeff2': balance_collection.get_raster('f_Ta_coeff2'),
        'f_Ta_coeff1': balance_collection.get_raster('f_Ta_coeff1'),
        'residual': balance_collection.get_raster('residual'),
        'era5_air_temperature': balance_collection.get_raster('era5_air_temperature')
    },
    districts_gdf=districts,
    transform=balance_collection.transform,
    stats=['mean']
)

# 3. 街区回归
model = DistrictRegressionModel()

X_F, X_S, f_Ta_coeffs, y_residual, era5_Ta_mean = model.prepare_regression_data(
    aggregated_df=aggregated,
    districts_gdf=districts,
    f_Ta_coeff2_column='f_Ta_coeff2_mean',
    f_Ta_coeff1_column='f_Ta_coeff1_mean',
    residual_column='residual_mean',
    era5_Ta_column='era5_air_temperature_mean',
    X_F_columns=['lcz_type', 'impervious_area'],
    X_S_columns=['building_volume']
)

results = model.fit_als_regression(
    X_F=X_F,
    X_S=X_S,
    f_Ta_coeff2=f_Ta_coeffs['coeff2'],
    f_Ta_coeff1=f_Ta_coeffs['coeff1'],
    y_residual=y_residual,
    Ts_mean=aggregated['surface_temperature_mean'],
    max_iter=20,
    tol=1e-4
)

# 4. 输出结果
results_df = model.get_results_dataframe(
    districts_gdf=districts,
    X_F_columns=['lcz_type', 'impervious_area'],
    X_S_columns=['building_volume']
)

results_df.to_file('output/ta_results.gpkg', driver='GPKG')
```

### 示例2：空间分析

```python
from src.analysis import (
    SpatialWeightMatrix,
    analyze_spatial_autocorrelation,
    analyze_overflow,
    CounterfactualAnalyzer
)
import geopandas as gpd

# 加载街区回归结果
results_gdf = gpd.read_file('output/ta_results.gpkg')

# 1. 构建空间权重矩阵
spatial_weights = SpatialWeightMatrix(
    districts_gdf=results_gdf,
    distance_threshold=5000.0,
    decay_function='gaussian',
    row_standardize=True,
    cache_dir='./cache/spatial'
)

print(f"空间权重矩阵摘要:")
print(f"  平均邻居数: {spatial_weights.summary()['avg_neighbors']:.1f}")

# 2. 空间自相关分析
Ta = results_gdf['Ta_optimized'].values
autocorr = analyze_spatial_autocorrelation(
    Ta=Ta,
    spatial_weights=spatial_weights,
    verbose=True
)
# 输出 Moran's I 和空间滞后模型结果

# 3. 溢出效应分析
overflow_result, gdf_with_overflow = analyze_overflow(
    gdf=results_gdf,
    ta_column='Ta_optimized',
    lcz_column='LCZ',
    distance_threshold=5000.0,
    decay_function='gaussian',
    cache_dir='./cache/spatial',
    verbose=True
)

# 保存带溢出分析结果的数据
gdf_with_overflow.to_file('output/ta_with_overflow.gpkg', driver='GPKG')

# 4. 反事实分析
from src.regression import ALSRegression

# 假设已有ALS模型和相关数据
cf_analyzer = CounterfactualAnalyzer(
    natural_lcz_values=[11, 12, 13, 14],
    replacement_lcz=6,  # 替换为开敞低层
    verbose=True
)

cf_result = cf_analyzer.analyze(
    als_model=als_model,
    districts_gdf=results_gdf,
    X_F=X_F,
    X_S=X_S,
    f_Ta_coeffs=f_Ta_coeffs,
    y_residual=y_residual,
    era5_Ta_mean=era5_Ta_mean,
    lcz_column='LCZ',
    include_spatial_analysis=True
)

# 输出摘要
print(cf_result.summary())

# 按LCZ类型分析
results_by_lcz = cf_analyzer.analyze_by_lcz_type(
    als_model=als_model,
    districts_gdf=results_gdf,
    X_F=X_F,
    X_S=X_S,
    f_Ta_coeffs=f_Ta_coeffs,
    y_residual=y_residual,
    era5_Ta_mean=era5_Ta_mean,
    lcz_column='LCZ'
)
# 分别输出树木、水体等的降温贡献
```

### 示例3：命令行使用

```bash
# 物理计算模式
python -m src physics \
    --era5 data/era5.tif \
    --landsat data/landsat.tif \
    --albedo data/albedo.tif \
    --dem data/dem.tif \
    --lcz data/lcz.tif \
    --datetime 202308151030 \
    --cachedir ./cache \
    -o output/balance.tif

# 街区回归模式
python -m src regression \
    --cachedir ./cache \
    --districts data/districts.gpkg \
    --x-f lcz_type,impervious_area \
    --x-s building_volume \
    -o output/ta_results.gpkg

# 完整工作流
python -m src full \
    --era5 data/era5.tif \
    --landsat data/landsat.tif \
    --albedo data/albedo.tif \
    --dem data/dem.tif \
    --lcz data/lcz.tif \
    --datetime 202308151030 \
    --districts data/districts.gpkg \
    --cachedir ./cache \
    --x-f lcz_type,impervious_area \
    --x-s building_volume \
    -o output/ta_results.gpkg

# 空间分析模式
python -m src spatial \
    --input output/ta_results.gpkg \
    --ta-column Ta_optimized \
    --lcz-column LCZ \
    --distance 5000 \
    --decay gaussian \
    --cachedir ./cache/spatial \
    -o output/spatial_analysis.gpkg
```

### 示例4：单独使用模块

```python
# 只计算能量平衡系数
from src.radiation import calculate_energy_balance_coefficients
import numpy as np

# 准备输入数据
S_down = np.random.rand(100, 100) * 800  # W/m²
Ts = np.random.rand(100, 100) * 20 + 290  # K
elev = np.random.rand(100, 100) * 1000  # m
albedo = np.random.rand(100, 100) * 0.3
ndvi = np.random.rand(100, 100) * 0.8 - 0.2
es = np.random.rand(100, 100) * 3 + 2  # kPa
ea = np.random.rand(100, 100) * 2 + 1  # kPa
rah = np.random.rand(100, 100) * 50 + 10  # s/m
rs = np.random.rand(100, 100) * 200 + 50  # s/m
eps0 = np.random.rand(100, 100) * 0.1 + 0.9
P = np.full((100, 100), 101325.0)  # Pa
Ta_era5 = np.full((100, 100), 298.15)  # K
lcz = np.random.randint(1, 15, (100, 100))

# 计算系数
coeffs = calculate_energy_balance_coefficients(
    shortwave_down=S_down,
    surface_temperature=Ts,
    elevation=elev,
    albedo=albedo,
    ndvi=ndvi,
    saturation_vapor_pressure=es,
    actual_vapor_pressure=ea,
    aerodynamic_resistance=rah,
    surface_resistance=rs,
    surface_emissivity=eps0,
    surface_pressure=P,
    era5_air_temperature=Ta_era5,
    lcz=lcz
)

print(f"Ta²系数: {coeffs['f_Ta_coeff2'].mean():.2f} W/m²/K²")
print(f"Ta系数: {coeffs['f_Ta_coeff1'].mean():.2f} W/m²/K")
print(f"残差: {coeffs['residual'].mean():.2f} W/m²")
```

---

## 数据格式

### 输入数据格式

**ERA5-Land** (GeoTIFF, 多波段):
- Band 1: `surface_pressure` (Pa)
- Band 2: `dewpoint_temperature_2m` (K)
- Band 3: `u_component_of_wind_10m` (m/s)
- Band 4: `v_component_of_wind_10m` (m/s)
- Band 5: `temperature_2m` (K, 仅用于参考)

**Landsat** (`landsat.tif`, GeoTIFF, 多波段):
- Band 9: `ndvi` - 归一化植被指数
- Band 10: `fvc` - 植被覆盖度
- Band 14: `emissivity` - 地表发射率
- Band 19: `lst` - 地表温度 (K)

**Albedo** (`albedo.tif`, GeoTIFF, 单波段):
- Band 1: `albedo` - 地表反照率 (0-1)

**DEM** (GeoTIFF, 单波段):
- Band 1: `elevation` - 高程 (m)

**LCZ** (GeoTIFF, 单波段):
- Band 1: `lcz` - LCZ分类 (1-14)

**Districts** (GeoPackage/Shapefile):
- 必需字段: `district_id` - 街区ID
- 可选字段: `lcz_type`, `impervious_area`, `population`, `building_volume`, `fvc_mean`

### 输出数据格式

**物理计算输出** (GeoTIFF, 多波段):
- Band 1: `f_Ta_coeff2` - Ta²系数 (W/m²/K²)
- Band 2: `f_Ta_coeff1` - Ta系数 (W/m²/K)
- Band 3: `residual` - 残差 (W/m²)
- Band 4: `era5_air_temperature` - ERA5气温 (K)
- Band 5: `storage_feature` - 储热特征 (W/m²)

**回归输出** (GeoPackage/CSV):
- `district_id` - 街区ID
- `Ta_optimized` - 估算气温 (K)
- `Ta_celsius` - 气温 (°C)
- `coeff_F_*` - 人为热回归系数
- `coeff_S_*` - 储热回归系数

---

## 性能优化

### 1. 缓存系统

使用`CachedRasterCollection`将中间结果缓存到磁盘：
```python
collection = CachedRasterCollection(
    cache_dir=Path('./cache'),
    target_resolution=10.0,
    target_crs='EPSG:32650'
)
```

### 2. 分块处理

大尺度区域自动分块处理，避免内存溢出。

### 3. 并行计算

部分计算支持多进程并行（未来版本）。

---

## 调试工具

### 诊断工具

```python
from test.energy_balance_diagnostics import EnergyBalanceDiagnostics

diagnostics = EnergyBalanceDiagnostics()
diagnostics.check_energy_balance(coeffs)
diagnostics.plot_coefficients(coeffs)
```

### 验证函数

```python
from src.radiation import validate_energy_balance

validate_energy_balance(
    f_Ta_coeff2=coeffs['f_Ta_coeff2'],
    f_Ta_coeff1=coeffs['f_Ta_coeff1'],
    residual=coeffs['residual'],
    ta_test=298.15
)
```

---

## 常见问题

### Q: 如何检查能量平衡是否合理？

A: 使用验证函数检查系数和残差的合理性：
```python
validate_energy_balance(coeffs['f_Ta_coeff2'], coeffs['f_Ta_coeff1'], coeffs['residual'])
```

### Q: 如何调整回归特征？

A: 在`prepare_regression_data()`中指定`X_F_columns`和`X_S_columns`：
```python
X_F_columns=['lcz_type', 'impervious_area', 'population']
X_S_columns=['building_volume', 'fvc_mean']
```

### Q: 如何提高计算速度？

A: 
1. 使用缓存系统避免重复计算
2. 降低目标分辨率
3. 使用更小的研究区域

---

## 参考文献

1. 代码注释和文档字符串
2. `doc-old/` 目录中的旧文档
3. `src/radiation/README.md` - 辐射模块详细文档

---

**最后更新**: 2025-01-XX

