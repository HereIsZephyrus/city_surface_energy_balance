# 使用指南

## 目录
1. [安装与环境配置](#安装与环境配置)
2. [数据准备](#数据准备)
3. [快速开始](#快速开始)
4. [详细使用说明](#详细使用说明)
5. [参数配置](#参数配置)
6. [结果解读](#结果解读)
7. [常见问题](#常见问题)

---

## 安装与环境配置

### 系统要求

- Python 3.8+
- Linux / macOS / Windows
- 至少 8GB RAM（推荐 16GB+）
- 足够的磁盘空间（用于缓存，建议 50GB+）

### 安装步骤

```bash
# 1. 克隆仓库
git clone <repository-url>
cd city_surface_energy_balance

# 2. 创建虚拟环境（推荐）
python -m venv venv
source venv/bin/activate  # Linux/macOS
# 或
venv\Scripts\activate  # Windows

# 3. 安装依赖
pip install -r requirements.txt

# 4. 验证安装
python -m src --help
```

### 依赖包

主要依赖包：
- `numpy>=1.20.0`
- `rasterio>=1.2.0`
- `geopandas>=0.10.0`
- `pandas>=1.3.0`
- `scipy>=1.7.0`
- `scikit-learn>=1.0.0`

---

## 数据准备

### 1. ERA5-Land 数据

**获取方式**：
- Google Earth Engine
- Copernicus Climate Data Store (CDS)
- 其他ERA5数据源

**必需变量**：
| 变量名 | ERA5-Land Band | 单位 | 说明 |
|--------|---------------|------|------|
| 地表气压 | `surface_pressure` | Pa | 用于计算空气密度 |
| 露点温度 | `dewpoint_temperature_2m` | K | 用于计算实际水汽压 |
| U风速分量 | `u_component_of_wind_10m` | m/s | 用于计算风速 |
| V风速分量 | `v_component_of_wind_10m` | m/s | 用于计算风速 |
| 气温（参考） | `temperature_2m` | K | 仅用于参考，不参与计算 |

**数据格式**：
- GeoTIFF格式
- 多波段，每个波段对应一个变量
- 空间分辨率：0.1° × 0.1° (约11km)
- 时间分辨率：每小时

**预处理**：
```python
# 示例：从ERA5数据创建多波段GeoTIFF
import rasterio
import numpy as np

# 假设已有ERA5数据数组
bands = {
    'surface_pressure': pressure_array,      # Pa
    'dewpoint_temperature_2m': dewpoint_array, # K
    'u_component_of_wind_10m': u_wind_array,   # m/s
    'v_component_of_wind_10m': v_wind_array,   # m/s
    'temperature_2m': temp_array                # K (参考)
}

# 保存为多波段GeoTIFF
with rasterio.open('era5.tif', 'w', driver='GTiff',
                  height=pressure_array.shape[0],
                  width=pressure_array.shape[1],
                  count=5, dtype=rasterio.float32,
                  crs='EPSG:4326',
                  transform=transform) as dst:
    for i, (name, array) in enumerate(bands.items(), 1):
        dst.write(array, i)
        dst.set_band_description(i, name)
```

### 2. Landsat 数据

**获取方式**：
- USGS EarthExplorer
- Google Earth Engine
- 其他Landsat数据源

**必需变量**：
| 变量名 | 文件 | 单位 | 说明 |
|--------|------|------|------|
| 地表温度 | `landsat.tif` | K | LST（多波段文件中的一层） |
| NDVI | `landsat.tif` | 无量纲 | 归一化植被指数 |
| 反照率 | `albedo.tif` | 0-1 | 宽波段地表反照率（独立文件） |
| 发射率 | `landsat.tif` | 0-1 | 地表发射率 |

**数据格式**：
- `landsat.tif`: GeoTIFF，多波段（包含 LST/NDVI/FVC/发射率等中间产品）
- `albedo.tif`: GeoTIFF，单波段，数值范围 [0, 1]
- 空间分辨率：30m（Landsat 8/9）
- 时间：与ERA5数据时间匹配

**预处理示例**：
```python
# 从Landsat数据计算各变量
# 这里仅提供框架，具体计算需要根据Landsat产品类型调整

# 1. 计算NDVI
ndvi = (nir - red) / (nir + red)

# 2. 计算地表温度（单通道方法）
lst = calculate_lst_from_thermal_band(thermal_band, emissivity)

# 3. 计算发射率（NDVI阈值法）
emissivity = calculate_emissivity_from_ndvi(ndvi)

# 4. 计算反照率（可使用 script/compute_albedo.py）
albedo = calculate_albedo_from_bands(blue, green, red, nir, swir1, swir2)

# 保存主 Landsat 文件（不含 albedo）
# 注意: 本项目约定 NDVI/FVC/发射率/LST 分别位于 9/10/14/19 波段
# 可以先创建一个包含至少 19 个波段的空文件，再写入对应索引
with rasterio.open('landsat.tif', 'w', count=19, ...) as dst:
    dst.write(ndvi, 9)
    dst.write(fvc, 10)
    dst.write(emissivity, 14)
    dst.write(lst, 19)

# 保存独立的 Albedo 文件
with rasterio.open('albedo.tif', 'w', ...) as dst:
    dst.write(albedo, 1)
```

### 3. DEM 数据

**获取方式**：
- SRTM
- ASTER GDEM
- 其他DEM数据源

**要求**：
- GeoTIFF格式
- 单波段
- 空间分辨率：建议与Landsat匹配（30m）或更高
- 单位：米

### 4. LCZ 分类数据

**获取方式**：
- 使用LCZ Generator生成
- 使用本项目提供的LCZ分类算法
- 其他LCZ分类产品

**要求**：
- GeoTIFF格式
- 单波段
- 值范围：1-14（见LCZ编码说明）
- 空间分辨率：建议与Landsat匹配

**LCZ编码**：
- 1-9: 城市建筑类型
- 10: 裸岩/铺装
- 11: 密集树木
- 12: 灌木/低矮植被
- 13: 裸土/沙地
- 14: 水体

### 5. 街区矢量数据

**要求**：
- GeoPackage或Shapefile格式
- 必需字段：`district_id` - 街区ID
- 可选字段：
  - `lcz_type` - LCZ类型
  - `impervious_area` - 不透水面面积
  - `population` - 人口
  - `building_volume` - 建筑体积
  - `fvc_mean` - 植被覆盖度

**创建示例**：
```python
import geopandas as gpd
from shapely.geometry import Polygon

# 创建示例街区
districts = gpd.GeoDataFrame({
    'district_id': [1, 2, 3],
    'lcz_type': [6, 11, 1],
    'impervious_area': [0.6, 0.1, 0.8],
    'population': [5000, 2000, 10000],
    'geometry': [
        Polygon([(0, 0), (100, 0), (100, 100), (0, 100)]),
        Polygon([(100, 0), (200, 0), (200, 100), (100, 100)]),
        Polygon([(0, 100), (100, 100), (100, 200), (0, 200)])
    ]
}, crs='EPSG:32650')

districts.to_file('districts.gpkg', driver='GPKG')
```

---

## 快速开始

### 示例1：完整工作流（命令行）

```bash
# 执行完整工作流
python -m src full \
    --era5 data/era5.tif \
    --landsat data/landsat.tif \
    --albedo data/albedo.tif \
    --dem data/dem.tif \
    --lcz data/lcz.tif \
    --datetime 202308151030 \
    --districts data/districts.gpkg \
    --cachedir ./cache \
    --x-f lcz_type,impervious_area \
    --x-s building_volume \
    -o output/ta_results.gpkg
```

### 示例2：分步执行

```bash
# 步骤1：物理计算
python -m src physics \
    --era5 data/era5.tif \
    --landsat data/landsat.tif \
    --albedo data/albedo.tif \
    --dem data/dem.tif \
    --lcz data/lcz.tif \
    --datetime 202308151030 \
    --cachedir ./cache \
    -o output/balance.tif

# 步骤2：街区回归
python -m src regression \
    --cachedir ./cache \
    --districts data/districts.gpkg \
    --x-f lcz_type,impervious_area \
    --x-s building_volume \
    -o output/ta_results.gpkg

# 步骤3：空间分析（可选）
python -m src spatial \
    --input output/ta_results.gpkg \
    --ta-column Ta_optimized \
    --lcz-column LCZ \
    --distance 5000 \
    --decay gaussian \
    --cachedir ./cache/spatial \
    -o output/spatial_analysis.gpkg
```

### 示例3：Python API

```python
from datetime import datetime
from src.physics import load_and_align_data, calculate_aerodynamic_parameters
from src.radiation import calculate_energy_balance
from src.regression import DistrictAggregator, DistrictRegressionModel
import geopandas as gpd

# 1. 物理计算
collection = load_and_align_data(
    era5_path='data/era5.tif',
    landsat_path='data/landsat.tif',
    albedo_path='data/albedo.tif',
    dem_path='data/dem.tif',
    lcz_path='data/lcz.tif',
    target_crs='EPSG:32650',
    target_resolution=10.0,
    cache_dir='./cache'
)

aero_collection = calculate_aerodynamic_parameters(
    collection,
    cache_dir='./cache/aerodynamic'
)

balance_collection = calculate_energy_balance(
    input_collection=collection,
    aero_collection=aero_collection,
    datetime_obj=datetime(2023, 8, 15, 10, 30),
    std_meridian=120.0,
    cache_dir='./cache/balance'
)

# 2. 空间聚合
districts = gpd.read_file('data/districts.gpkg')
aggregator = DistrictAggregator()

aggregated = aggregator.aggregate_rasters_to_districts(
    rasters={
        'f_Ta_coeff2': balance_collection.get_raster('f_Ta_coeff2'),
        'f_Ta_coeff1': balance_collection.get_raster('f_Ta_coeff1'),
        'residual': balance_collection.get_raster('residual'),
        'era5_air_temperature': balance_collection.get_raster('era5_air_temperature')
    },
    districts_gdf=districts,
    transform=balance_collection.transform,
    stats=['mean']
)

# 3. 街区回归
model = DistrictRegressionModel()

X_F, X_S, f_Ta_coeffs, y_residual, era5_Ta_mean = model.prepare_regression_data(
    aggregated_df=aggregated,
    districts_gdf=districts,
    f_Ta_coeff2_column='f_Ta_coeff2_mean',
    f_Ta_coeff1_column='f_Ta_coeff1_mean',
    residual_column='residual_mean',
    era5_Ta_column='era5_air_temperature_mean',
    X_F_columns=['lcz_type', 'impervious_area'],
    X_S_columns=['building_volume']
)

results = model.fit_als_regression(
    X_F=X_F,
    X_S=X_S,
    f_Ta_coeff2=f_Ta_coeffs['coeff2'],
    f_Ta_coeff1=f_Ta_coeffs['coeff1'],
    y_residual=y_residual,
    Ts_mean=aggregated['surface_temperature_mean'],
    max_iter=20,
    tol=1e-4
)

# 4. 保存结果
results_df = model.get_results_dataframe(
    districts_gdf=districts,
    X_F_columns=['lcz_type', 'impervious_area'],
    X_S_columns=['building_volume']
)

results_df.to_file('output/ta_results.gpkg', driver='GPKG')

# 5. 空间分析（可选）
from src.analysis import (
    SpatialWeightMatrix,
    analyze_spatial_autocorrelation,
    analyze_overflow,
    CounterfactualAnalyzer
)

# 构建空间权重矩阵
spatial_weights = SpatialWeightMatrix(
    districts_gdf=results_df,
    distance_threshold=5000.0,
    decay_function='gaussian',
    cache_dir='./cache/spatial'
)

# 空间自相关分析（水平交换项 ΔQ_A）
autocorr_result = analyze_spatial_autocorrelation(
    Ta=results_df['Ta_optimized'].values,
    spatial_weights=spatial_weights,
    verbose=True
)

# 溢出效应分析
overflow_result, gdf_with_overflow = analyze_overflow(
    gdf=results_df,
    ta_column='Ta_optimized',
    lcz_column='LCZ',
    distance_threshold=5000.0,
    verbose=True
)

# 保存带空间分析结果的数据
gdf_with_overflow.to_file('output/ta_with_spatial.gpkg', driver='GPKG')
```

---

## 详细使用说明

### 命令行参数

#### physics 模式

```bash
python -m src physics [选项]
```

**必需参数**：
- `--era5`: ERA5 tif文件路径
- `--landsat`: Landsat tif文件路径
- `--albedo`: 独立的地表反照率tif文件路径
- `--dem`: DEM tif文件路径
- `--lcz`: LCZ栅格文件路径
- `--datetime`: 观测日期时间 (格式: YYYYMMDDHHMM)
- `-o, --output`: 输出tif文件路径

**可选参数**：
- `--building`: 建筑数据文件路径 (.gpkg)
- `--std-meridian`: 标准经度 (默认: 120.0)
- `--crs`: 目标坐标系 (默认: EPSG:32650)
- `--resolution`: 目标分辨率(m) (默认: 10.0)
- `--cachedir`: 缓存目录路径
- `--restart`: 强制重新计算并覆盖缓存

#### regression 模式

```bash
python -m src regression [选项]
```

**必需参数**：
- `--cachedir`: 缓存目录路径（physics模块输出）
- `--districts`: 街区矢量数据路径 (.gpkg)
- `-o, --output`: 输出文件路径

**可选参数**：
- `--district-id`: 街区ID字段名 (默认: district_id)
- `--x-f`: 人为热Q_F特征列名，逗号分隔
- `--x-s`: 储热ΔQ_Sb特征列名，逗号分隔
- `--x-a`: 水平交换ΔQ_A特征列名，逗号分隔
- `--max-iter`: ALS最大迭代次数 (默认: 20)
- `--tol`: 收敛容差 (默认: 1e-4)
- `--quiet`: 静默模式

#### full 模式

```bash
python -m src full [选项]
```

包含physics和regression模式的所有参数。

#### spatial 模式

```bash
python -m src spatial [选项]
```

空间分析模式，用于分析气温的空间自相关和溢出效应。

**必需参数**：
- `--input`: 输入文件路径（regression输出的.gpkg）
- `-o, --output`: 输出文件路径

**可选参数**：
- `--ta-column`: 气温列名 (默认: Ta_optimized)
- `--lcz-column`: LCZ列名 (默认: LCZ)
- `--distance`: 空间权重距离阈值(m) (默认: 5000.0)
- `--decay`: 距离衰减函数 (binary/linear/inverse/gaussian, 默认: gaussian)
- `--cachedir`: 空间权重矩阵缓存目录
- `--natural-lcz`: 自然景观LCZ值，逗号分隔 (默认: 11,12,13,14)
- `--built-lcz`: 建成区LCZ值，逗号分隔 (默认: 1-10)
- `--quiet`: 静默模式

**输出内容**：
- 空间自相关分析结果（Moran's I, 空间滞后模型）
- 溢出效应分析结果（自然邻居占比、溢出系数、局部Moran's I）
- 带分析结果的GeoPackage文件

---

## 参数配置

### 坐标系设置

**推荐坐标系**：
- 中国：`EPSG:32650` (UTM Zone 50N) 或 `EPSG:32651` (UTM Zone 51N)
- 其他地区：根据研究区域选择合适的UTM投影

**设置方法**：
```bash
--crs EPSG:32650
```

### 分辨率设置

**推荐分辨率**：
- 与Landsat匹配：30m
- 更高精度：10m（需要更高分辨率输入数据）
- 计算速度优先：50m或100m

**设置方法**：
```bash
--resolution 10.0
```

### 标准经度设置

**中国**：120.0（东八区）

**设置方法**：
```bash
--std-meridian 120.0
```

### ALS回归参数

**最大迭代次数**：
- 默认：20
- 复杂区域：30-50
- 简单区域：10-15

**收敛容差**：
- 默认：1e-4
- 高精度：1e-5
- 快速：1e-3

**设置方法**：
```bash
--max-iter 30 --tol 1e-5
```

---

## 结果解读

### 物理计算输出

**文件**：`output/balance.tif` (多波段GeoTIFF)

**波段说明**：
- Band 1: `f_Ta_coeff2` - Ta²系数 (W/m²/K²)
- Band 2: `f_Ta_coeff1` - Ta系数 (W/m²/K)
- Band 3: `residual` - 残差 (W/m²)
- Band 4: `era5_air_temperature` - ERA5气温 (K, 参考)
- Band 5: `storage_feature` - 储热特征 (W/m²)

**解读**：
- `f_Ta_coeff2` 和 `f_Ta_coeff1` 用于街区回归
- `residual` 表示不依赖Ta的能量平衡残差
- `era5_air_temperature` 用于Ta初始化和参考

### 回归输出

**文件**：`output/ta_results.gpkg` (GeoPackage)

**字段说明**：
- `district_id`: 街区ID
- `Ta_optimized`: 估算气温 (K)
- `Ta_celsius`: 气温 (°C)
- `coeff_F_*`: 人为热回归系数
- `coeff_S_*`: 储热回归系数
- `R_squared`: 回归R²（如果计算）

**解读**：
- `Ta_optimized` 是每个街区的估算近地表气温
- `coeff_F_*` 表示人为热对气温的影响
- `coeff_S_*` 表示储热对气温的影响

### 空间分析输出

**文件**：`output/spatial_analysis.gpkg` (GeoPackage)

**字段说明**：
- `natural_neighbor_ratio`: 自然邻居占比 (0-1)
- `local_moran_i`: 局部 Moran's I 值
- `cluster_type`: 空间聚集类型
  - `Hot-Hot`: 高温聚集
  - `Cold-Cold`: 低温聚集
  - `High-Low`: 高温异常点
  - `Low-High`: 低温异常点
- `is_natural`: 是否为自然景观街区
- `is_built`: 是否为建成区街区

### 结果验证

```python
import geopandas as gpd
import matplotlib.pyplot as plt

# 加载结果
results = gpd.read_file('output/ta_results.gpkg')

# 检查气温范围
print(f"气温范围: {results['Ta_celsius'].min():.2f} - {results['Ta_celsius'].max():.2f} °C")
print(f"平均气温: {results['Ta_celsius'].mean():.2f} °C")

# 可视化
fig, ax = plt.subplots(figsize=(10, 8))
results.plot(column='Ta_celsius', ax=ax, legend=True, cmap='coolwarm')
plt.title('估算近地表气温分布')
plt.show()
```

---

## 常见问题

### Q1: 数据对齐失败

**问题**：不同数据源的坐标系或分辨率不一致

**解决方案**：
1. 检查所有输入数据的坐标系
2. 使用`--crs`参数统一坐标系
3. 使用`--resolution`参数统一分辨率
4. 确保所有数据覆盖相同的空间范围

### Q2: 内存不足

**问题**：处理大尺度区域时内存溢出

**解决方案**：
1. 使用`--cachedir`启用磁盘缓存
2. 降低`--resolution`（如从10m改为30m）
3. 分块处理研究区域
4. 增加系统内存

### Q3: ALS回归不收敛

**问题**：回归迭代达到最大次数仍未收敛

**解决方案**：
1. 增加`--max-iter`（如30或50）
2. 放宽`--tol`（如1e-3）
3. 检查输入数据质量
4. 检查回归特征是否合理

### Q4: 气温结果不合理

**问题**：估算的气温值超出合理范围

**可能原因**：
1. 输入数据质量问题
2. LCZ分类错误
3. 回归特征选择不当

**解决方案**：
1. 检查输入数据（LST、NDVI等）是否合理
2. 验证LCZ分类准确性
3. 调整回归特征（`--x-f`, `--x-s`）
4. 检查ERA5数据时间是否匹配

### Q5: 计算速度慢

**问题**：计算耗时过长

**解决方案**：
1. 使用`--cachedir`避免重复计算
2. 降低分辨率
3. 缩小研究区域
4. 使用更快的存储设备（SSD）

### Q6: 缓存文件损坏

**问题**：缓存文件无法加载

**解决方案**：
```bash
# 使用--restart参数强制重新计算
python -m src physics ... --restart
```

### Q7: 缺少必需字段

**问题**：街区矢量数据缺少必需字段

**解决方案**：
1. 确保有`district_id`字段
2. 如果使用回归特征，确保对应字段存在
3. 检查字段名称是否匹配（`--district-id`参数）

---

## 最佳实践

### 1. 数据质量控制

- 检查Landsat数据云量（建议<10%）
- 验证LCZ分类准确性
- 确保ERA5数据时间与Landsat匹配
- 检查DEM数据质量

### 2. 参数选择

- 根据研究区域选择合适的坐标系
- 分辨率与数据源匹配（不要过度插值）
- 回归特征选择要有物理意义

### 3. 结果验证

- 与气象站观测数据对比
- 检查气温空间分布是否合理
- 验证回归系数符号是否合理

### 4. 性能优化

- 使用缓存系统
- 合理设置分辨率
- 分块处理大区域

---

## 技术支持

### 文档

- 算法思想：`doc/算法思想.md`
- 数学模型：`doc/数学模型.md`
- 具体实现：`doc/具体实现.md`
- 本使用指南：`doc/使用指南.md`

### 示例代码

- `examples/` 目录包含示例脚本

### 问题反馈

如遇到问题，请：
1. 检查本文档的常见问题部分
2. 查看代码注释和文档字符串
3. 提交Issue（如果适用）

---

**最后更新**: 2025-01-XX

